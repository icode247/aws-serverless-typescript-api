"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EsbuildServerlessPlugin = void 0;
const esbuild_1 = require("esbuild");
const fs = require("fs-extra");
const globby = require("globby");
const path = require("path");
const pMap = require("p-map");
const ramda_1 = require("ramda");
const chokidar = require("chokidar");
const helper_1 = require("./helper");
const pack_externals_1 = require("./pack-externals");
const pack_1 = require("./pack");
const pre_offline_1 = require("./pre-offline");
const pre_local_1 = require("./pre-local");
const utils_1 = require("./utils");
const constants_1 = require("./constants");
const DEFAULT_BUILD_OPTIONS = {
    bundle: true,
    target: 'node10',
    external: [],
    exclude: ['aws-sdk'],
    nativeZip: false,
    packager: 'npm',
    installExtraArgs: [],
    watch: {
        pattern: './**/*.(js|ts)',
        ignore: [constants_1.WORK_FOLDER, 'dist', 'node_modules', constants_1.SERVERLESS_FOLDER],
    },
    keepOutputDirectory: false,
    packagerOptions: {},
};
class EsbuildServerlessPlugin {
    constructor(serverless, options) {
        this.getCachedOptions = (0, ramda_1.memoizeWith)((0, ramda_1.always)('cache'), () => {
            var _a, _b;
            const runtimeMatcher = helper_1.providerRuntimeMatcher[this.serverless.service.provider.name];
            const target = runtimeMatcher === null || runtimeMatcher === void 0 ? void 0 : runtimeMatcher[this.serverless.service.provider.runtime];
            const resolvedOptions = Object.assign({}, (target ? { target } : {}));
            const withDefaultOptions = (0, ramda_1.mergeRight)(DEFAULT_BUILD_OPTIONS);
            const withResolvedOptions = (0, ramda_1.mergeRight)(withDefaultOptions(resolvedOptions));
            return withResolvedOptions((_b = (_a = this.serverless.service.custom) === null || _a === void 0 ? void 0 : _a.esbuild) !== null && _b !== void 0 ? _b : {});
        });
        this.serverless = serverless;
        this.options = options;
        this.packExternalModules = pack_externals_1.packExternalModules.bind(this);
        this.pack = pack_1.pack.bind(this);
        this.preOffline = pre_offline_1.preOffline.bind(this);
        this.preLocal = pre_local_1.preLocal.bind(this);
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore old versions use servicePath, new versions serviceDir. Types will use only one of them
        this.serviceDirPath = this.serverless.config.serviceDir || this.serverless.config.servicePath;
        this.workDirPath = path.join(this.serviceDirPath, constants_1.WORK_FOLDER);
        this.buildDirPath = path.join(this.workDirPath, constants_1.BUILD_FOLDER);
        this.hooks = {
            'before:run:run': () => __awaiter(this, void 0, void 0, function* () {
                yield this.bundle();
                yield this.packExternalModules();
                yield this.copyExtras();
            }),
            'before:offline:start': () => __awaiter(this, void 0, void 0, function* () {
                yield this.bundle(true);
                yield this.packExternalModules();
                yield this.copyExtras();
                yield this.preOffline();
                this.watch();
            }),
            'before:offline:start:init': () => __awaiter(this, void 0, void 0, function* () {
                yield this.bundle(true);
                yield this.packExternalModules();
                yield this.copyExtras();
                yield this.preOffline();
                this.watch();
            }),
            'before:package:createDeploymentArtifacts': () => __awaiter(this, void 0, void 0, function* () {
                yield this.bundle();
                yield this.packExternalModules();
                yield this.copyExtras();
                yield this.pack();
            }),
            'after:package:createDeploymentArtifacts': () => __awaiter(this, void 0, void 0, function* () {
                yield this.cleanup();
            }),
            'before:deploy:function:packageFunction': () => __awaiter(this, void 0, void 0, function* () {
                yield this.bundle();
                yield this.packExternalModules();
                yield this.copyExtras();
                yield this.pack();
            }),
            'after:deploy:function:packageFunction': () => __awaiter(this, void 0, void 0, function* () {
                yield this.cleanup();
            }),
            'before:invoke:local:invoke': () => __awaiter(this, void 0, void 0, function* () {
                yield this.bundle();
                yield this.packExternalModules();
                yield this.copyExtras();
                yield this.preLocal();
            }),
        };
    }
    /**
     * Checks if the runtime for the given function is nodejs.
     * If the runtime is not set , checks the global runtime.
     * @param {Serverless.FunctionDefinitionHandler} func the function to be checked
     * @returns {boolean} true if the function/global runtime is nodejs; false, otherwise
     */
    isNodeFunction(func) {
        const runtime = func.runtime || this.serverless.service.provider.runtime;
        const runtimeMatcher = helper_1.providerRuntimeMatcher[this.serverless.service.provider.name];
        return Boolean(runtimeMatcher === null || runtimeMatcher === void 0 ? void 0 : runtimeMatcher[runtime]);
    }
    /**
     * Checks if the function has a handler
     * @param {Serverless.FunctionDefinitionHandler | Serverless.FunctionDefinitionImage} func the function to be checked
     * @returns {boolean} true if the function has a handler
     */
    isFunctionDefinitionHandler(func) {
        var _a;
        return Boolean((_a = func) === null || _a === void 0 ? void 0 : _a.handler);
    }
    get functions() {
        const functions = this.options.function
            ? {
                [this.options.function]: this.serverless.service.getFunction(this.options.function),
            }
            : this.serverless.service.functions;
        // ignore all functions with a different runtime than nodejs:
        const nodeFunctions = {};
        for (const [functionAlias, fn] of Object.entries(functions)) {
            if (this.isFunctionDefinitionHandler(fn) && this.isNodeFunction(fn)) {
                nodeFunctions[functionAlias] = fn;
            }
        }
        return nodeFunctions;
    }
    get plugins() {
        if (!this.buildOptions.plugins)
            return;
        const plugins = require(path.join(this.serviceDirPath, this.buildOptions.plugins));
        if (typeof plugins === 'function') {
            return plugins(this.serverless);
        }
        return plugins;
    }
    get buildOptions() {
        return this.getCachedOptions();
    }
    get rootFileNames() {
        return (0, helper_1.extractFileNames)(this.serviceDirPath, this.serverless.service.provider.name, this.functions);
    }
    watch() {
        return __awaiter(this, void 0, void 0, function* () {
            const options = {
                ignored: this.buildOptions.watch.ignore,
                awaitWriteFinish: true,
                ignoreInitial: true,
            };
            chokidar.watch(this.buildOptions.watch.pattern, options).on('all', () => this.bundle(true)
                .then(() => this.serverless.cli.log('Watching files for changes...'))
                .catch(() => this.serverless.cli.log('Bundle error, waiting for a file change to reload...')));
        });
    }
    prepare() {
        var _a, _b, _c, _d, _e, _f;
        fs.mkdirpSync(this.buildDirPath);
        fs.mkdirpSync(path.join(this.workDirPath, constants_1.SERVERLESS_FOLDER));
        // exclude serverless-esbuild
        this.serverless.service.package = Object.assign(Object.assign({}, (this.serverless.service.package || {})), { patterns: [
                ...new Set([
                    ...(((_a = this.serverless.service.package) === null || _a === void 0 ? void 0 : _a.include) || []),
                    ...(((_b = this.serverless.service.package) === null || _b === void 0 ? void 0 : _b.exclude) || []).map((0, ramda_1.concat)('!')),
                    ...(((_c = this.serverless.service.package) === null || _c === void 0 ? void 0 : _c.patterns) || []),
                    '!node_modules/serverless-esbuild',
                ]),
            ] });
        for (const fn of Object.values(this.functions)) {
            fn.package = Object.assign(Object.assign({}, (fn.package || {})), { patterns: [
                    ...new Set([
                        ...(((_d = fn.package) === null || _d === void 0 ? void 0 : _d.include) || []),
                        ...(((_e = fn.package) === null || _e === void 0 ? void 0 : _e.exclude) || []).map((0, ramda_1.concat)('!')),
                        ...(((_f = fn.package) === null || _f === void 0 ? void 0 : _f.patterns) || []),
                    ]),
                ] });
        }
    }
    bundle(incremental = false) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this.prepare();
            this.serverless.cli.log(`Compiling to ${this.buildOptions.target} bundle with esbuild...`);
            if (this.buildOptions.disableIncremental === true) {
                incremental = false;
            }
            const bundleMapper = (bundleInfo) => __awaiter(this, void 0, void 0, function* () {
                const { entry, func, functionAlias } = bundleInfo;
                const config = Object.assign(Object.assign({}, this.buildOptions), { external: [
                        ...this.buildOptions.external,
                        ...(this.buildOptions.exclude === '*' || this.buildOptions.exclude.includes('*')
                            ? []
                            : this.buildOptions.exclude),
                    ], entryPoints: [entry], outdir: path.join(this.buildDirPath, path.dirname(entry)), platform: 'node', incremental, plugins: this.plugins });
                // esbuild v0.7.0 introduced config options validation, so I have to delete plugin specific options from esbuild config.
                delete config['concurrency'];
                delete config['exclude'];
                delete config['nativeZip'];
                delete config['packager'];
                delete config['packagePath'];
                delete config['watch'];
                delete config['keepOutputDirectory'];
                delete config['packagerOptions'];
                delete config['installExtraArgs'];
                delete config['disableIncremental'];
                const bundlePath = entry.substr(0, entry.lastIndexOf('.')) + '.js';
                if (this.buildResults) {
                    const { result } = this.buildResults.find(({ func: fn }) => fn.name === func.name);
                    if (result.rebuild) {
                        yield result.rebuild();
                        return { result, bundlePath, func, functionAlias };
                    }
                }
                const result = yield (0, esbuild_1.build)(config);
                if (config.metafile) {
                    fs.writeFileSync(path.join(this.buildDirPath, `${(0, utils_1.trimExtension)(entry)}-meta.json`), JSON.stringify(result.metafile, null, 2));
                }
                return { result, bundlePath, func, functionAlias };
            });
            this.serverless.cli.log(`Compiling with concurrency: ${(_a = this.buildOptions.concurrency) !== null && _a !== void 0 ? _a : 'Infinity'}`);
            this.buildResults = yield pMap(this.rootFileNames, bundleMapper, {
                concurrency: this.buildOptions.concurrency,
            });
            this.serverless.cli.log('Compiling completed.');
            return this.buildResults.map((r) => r.result);
        });
    }
    /** Link or copy extras such as node_modules or package.patterns definitions */
    copyExtras() {
        return __awaiter(this, void 0, void 0, function* () {
            const { service } = this.serverless;
            // include any "extras" from the "patterns" section
            if (service.package.patterns.length > 0) {
                const files = yield globby(service.package.patterns);
                for (const filename of files) {
                    const destFileName = path.resolve(path.join(this.buildDirPath, filename));
                    const dirname = path.dirname(destFileName);
                    if (!fs.existsSync(dirname)) {
                        fs.mkdirpSync(dirname);
                    }
                    if (!fs.existsSync(destFileName)) {
                        fs.copySync(path.resolve(filename), destFileName);
                    }
                }
            }
            // include any "extras" from the individual function "patterns" section
            for (const [functionAlias, fn] of Object.entries(this.functions)) {
                if (fn.package.patterns.length === 0) {
                    continue;
                }
                const files = yield globby(fn.package.patterns);
                for (const filename of files) {
                    const destFileName = path.resolve(path.join(this.buildDirPath, `${constants_1.ONLY_PREFIX}${functionAlias}`, filename));
                    const dirname = path.dirname(destFileName);
                    if (!fs.existsSync(dirname)) {
                        fs.mkdirpSync(dirname);
                    }
                    if (!fs.existsSync(destFileName)) {
                        fs.copySync(path.resolve(filename), destFileName);
                    }
                }
            }
        });
    }
    /**
     * Move built code to the serverless folder, taking into account individual
     * packaging preferences.
     */
    moveArtifacts() {
        return __awaiter(this, void 0, void 0, function* () {
            const { service } = this.serverless;
            yield fs.copy(path.join(this.workDirPath, constants_1.SERVERLESS_FOLDER), path.join(this.serviceDirPath, constants_1.SERVERLESS_FOLDER));
            if (this.options.function) {
                const fn = service.getFunction(this.options.function);
                fn.package.artifact = path.join(this.serviceDirPath, constants_1.SERVERLESS_FOLDER, path.basename(fn.package.artifact));
                return;
            }
            if (service.package.individually) {
                const functionNames = service.getAllFunctions();
                functionNames.forEach((name) => {
                    service.getFunction(name).package.artifact = path.join(this.serviceDirPath, constants_1.SERVERLESS_FOLDER, path.basename(service.getFunction(name).package.artifact));
                });
                return;
            }
            service.package.artifact = path.join(this.serviceDirPath, constants_1.SERVERLESS_FOLDER, path.basename(service.package.artifact));
        });
    }
    cleanup() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.moveArtifacts();
            // Remove temp build folder
            if (!this.buildOptions.keepOutputDirectory) {
                fs.removeSync(path.join(this.workDirPath));
            }
        });
    }
}
exports.EsbuildServerlessPlugin = EsbuildServerlessPlugin;
module.exports = EsbuildServerlessPlugin;
